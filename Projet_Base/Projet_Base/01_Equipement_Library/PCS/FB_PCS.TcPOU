<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_PCS" Id="{908cd4cb-14f7-4d65-b719-2077e4e3cf2d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PCS EXTENDS FB_PCS_Base
//////////////////
// PLC controller . Jema Object 
//////////////////

VAR_INPUT PERSISTENT
	// Parameters of the Object
		ParamPnom							: REAL := 1500.0;	// (kW) Nominal power
		ParamQnom							: REAL := 1500.0;	// (kW) Nominal power
		ParamSmax							: REAL := 1500.0;	// (kVA) Maximum apparent power of the PCS (lasts 30s)
		
		ParamTimeoutCmdQ					: TIME := T#15S; 	// Time to activate or deactivate Q regulation before an alarm is raised
		ParamTimeoutCmdCosPhi				: TIME := T#15S; 	// Time to activate or deactivate CosPhi regulation before an alarm is raised
		ParamTimeoutQvU						: TIME := T#15S;	// Time to activate or deactivate Q(U) regulation before an alarm is raised
		ParamTimeoutPvF						: TIME := T#15S;	// Time to activate or deactivate P(f) regulation before an alarm is raised
    	                            		
		ParamSetPtModbusMode				: BOOL := TRUE;		// If True, then Setpoints come from Modbus
		ParamPoverQ							: BOOL := TRUE;		// If P over Q is True, then Max setpoint for Q calculated from setpoint of P
    	                    			
		ParamQfU_UDbHigh    				: REAL;				// JEMA U1 : AKUO U_UDbHigh
		ParamQfU_Umax		    			: REAL;				// JEMA U2 : AKUO U_Umax
		ParamQfU_UDbLow	    				: REAL;				// JEMA U3 : AKUO U_UDbLow
		ParamQfU_Umin		    			: REAL;				// JEMA U4 : AKUO U_Umin
		                            		
		ParamQfU_QDbHigh					: REAL;				// JEMA Q1 : AKUO U_QDbHigh
		ParamQfU_Qmax						: REAL;				// JEMA Q2 : AKUO U_Qmax
		ParamQfU_QDbLow						: REAL;				// JEMA Q3 : AKUO U_QDbLow
		ParamQfU_Qmin						: REAL;				// JEMA Q4 : AKUO U_Qmin
    	                            		
		ParamPfF_FDbHigh	    			: REAL;				// JEMA f1 : AKUO P_FDbHigh
		ParamPfF_Fmax		    			: REAL;				// JEMA f2 : AKUO P_Fmax
		ParamPfF_FDbLow	    				: REAL;				// JEMA f3 : AKUO P_FDbLow
		ParamPfF_Fmin		    			: REAL;				// JEMA f4 : AKUO P_Fmin
		                            		
		ParamPfF_PDbHigh					: REAL;				// JEMA P1 : AKUO P_PDbHigh
		ParamPfF_Pmax						: REAL;				// JEMA P2 : AKUO P_Pmax
		ParamPfF_PDbLow						: REAL;				// JEMA P3 : AKUO P_PDbLow
		ParamPfF_Pmin						: REAL;				// JEMA P4 : AKUO P_Pmin
    	
		ParamPfF_FhystLow					: REAL;				// JEMA fst1
		ParamPfF_FhystHigh					: REAL;				// JEMA fst2
		
		ParamFLow_droop						: REAL;				// (Hz) flow frequency (droop curve)
		ParamFHigh_droop					: REAL;				// (Hz) fhigh frequency (droop curve)
		ParamULow_droop						: REAL;				// (V) Ulow voltage (droop curve)
		ParamUHigh_droop					: REAL;				// (V) Ulow voltage (droop curve)
		
    	         	    		
		ParamTimeSoCRangeReachedRmp			: TIME;				// (ms) Time to ramp P back to the setpoint after the SoC reached its limits
		ParamTimeFreqRegStbDuration			: TIME;				// (ms) Time to ramp P back to the setpoint after entering the stable 
		ParamTimeEnterStblPriorRmp			: TIME; 			// (ms) Time to wait after entering the stable before ramping the P back to the setpoint
		    
    	                            	
		ParamTimeoutGridFormerTransition	: TIME := T#1M ;	// (ms) Time elapsed after grid former cmd when an alarm is raised
		ParamTimeoutGridFeederTransition	: TIME := T#1M;		// (ms) Time elapsed after grid feeder cmd when an alarm is raised
 		ParamTimeoutOffTransition			: TIME := T#1M;		// (ms) Time elapsed after CmdStop cmd when an alarm is raised
   	
		ParamFreqRegSoCmax 					: REAL;	 			// Jema Stops charging setpoint and overfreq regulation if BESS reaches this value
		ParamFreqRegSoCmin 					: REAL;				// Jema Stops discharging setpoint and underfreq regulation if BESS reaches this value
    	
		ParamLVRT_Enabled					: BOOL; 			// LVRT Enabled 
		ParamAntiIslanding_Enabled			: BOOL;				// Is Anti Islanding enabled

		ParamDeactivateWatchdog				: BOOL := TRUE;				// Parameter to deactivate the watchdog
		ParamMicroCyclingPower				: REAL;				// (kW) Active power the PCS will have during microcyling
		ParamMicroCyclingSoCMax				: REAL;				// (%) MaxSoC to reach before inverting Power
		ParamMicroCyclingSoCMin				: REAL;				// (%) MinSoC to reach before inverting Power
		ParamSocMax_L						: REAL;				// (%)  Max SOC Local
		ParamSocMin_L						: REAL;				// (%)  Min SOC Local
		ParamSocVeryVeryHigh				: REAL;				// (%) High SoC High Hysteresis
		ParamSocVeryHigh					: REAL;				// (%) High SoC Low Hysteresis
		ParamSocVeryVeryLow					: REAL;				// (%) Low SoC High Hysteresis
		ParamSocVeryLow						: REAL;				// (%) Low SoC Low Hysteresis 
				
 
	// Not Used at the moment : used to calculate theoretical Efficiency
		ParamRendementPcsNom				: REAL := 98;		// (%) Nominal Efficiency of the PCS at optimal conditions  
		ParamRendementPcsMin				: REAL := 80;		// (%) Minimal Efficiency of the PCS at P = 0  
		ParamTauxDeChargeRef				: REAL := 10;		// (%) LoadFactor where 1/5 of the efficiency is reached             			
END_VAR 
VAR_INPUT   	                   			
	// Commands :
		IN_CmdInvLocal						: BOOL;				// PCS is not included in available PCS' pool (excluded from HPP control). 
		IN_CmdStopOperation					: BOOL;				// BESS Specific command : Stop operation		
		IN_CmdPreventStart					: BOOL;				// BESS Specific command : Prevent start	
		IN_CmdOpenAC						: BOOL;				// Cmd To send an Open AC order
		IN_CmdOpenDC						: BOOL;				// Cmd To send an Open DC order	
 		IN_CmdP_On							: BOOL;				// Cmd start regulating on SetptP from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdQ_On							: BOOL;				// Cmd start regulating on SetptQ from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdCosPhi_On						: BOOL;				// Cmd start regulating on SetptCosPhi from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdP_Off							: BOOL;				// Cmd start regulating on SetptP from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdQ_Off							: BOOL;				// Cmd start regulating on SetptQ from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdCosPhi_Off					: BOOL;				// Cmd start regulating on SetptCosPhi from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdFreqregOn						: BOOL;				// Cmd 
		IN_CmdFreqregOff					: BOOL;				// 
		IN_CmdUregOn						: BOOL;				// 
		IN_CmdUregOff						: BOOL;				// 
		IN_CmdMicroCyclingOn				: BOOL;				// 
		IN_CmdMicroCyclingOff				: BOOL;				// 
		IN_CmdStandby						: BOOL;				// Cmd To send a soft Stop (No opening and closing of the AC/DC switch )
		IN_CmdStart							: BOOL;				// Cmd To send a start to the PCS (Does the full procedure, Soft + Close AC + Close DC)
		IN_CmdStop							: BOOL;				// Cmd To send a stop to the PCS (Soft Stop + Open DC + Open AC)
		
		                            		
		IN_CmdBlackStart					: BOOL; 			// Cmd Black start from outside of PCS : if you wan to know from what source, add a _IO2 value
		IN_CmdGridFormer					: BOOL;				// 
		IN_CmdGridFeeder					: BOOL;				// 
		IN_SetptP_Local						: REAL;				// Local Command
		IN_SetptQ_Local						: REAL;				// Local Command
		IN_SetptU_Local						: REAL := 500;	// Local Command
		IN_SetptF_Local						: REAL := 50;		// Local Command
		
		IN_CmdWatchdog						: BOOL ; 			// Activate or Deactivate the Watchdog function
	                
END_VAR
VAR_OUTPUT
	//Child objects
		OUT_SetptP_IO					: INT;			// (NA) Analogical value for the active power setpoint (based on ParamPnom)
		OUT_SetptQ_IO					: INT;			// (NA) Analogical value for the reactive power setpoint (based on ParamQnom)

END_VAR
VAR          


	MesDataExd								: PCS_Jema ;
                           	
	//M_ALARMMANAGEMENT VARIABLES//  
		AX_AlarmWords						: ARRAY[1..30] OF ST_ValuesAlarms;
		AX_AlarmWords_Null					: ARRAY[1..30] OF ST_ValuesAlarms;
		AX_AlarmWordsJema					: ARRAY[1..225] OF ST_ValuesAlarms;
		AX_AlarmWordsJema_Null				: ARRAY[1..225] OF ST_ValuesAlarms;
		NumAlarmsActive						: UINT;
		NumAlarmsActiveJema					: UINT;
	//M_READ VARIABLES//            		
		ModbusRead            				: ARRAY [1..4] OF FB_ModbusRead ; 	// (NA) FB for Modbus Reading
		MesBlock1_Temp						: ARRAY [1..4] OF ARRAY[1..120] OF WORD ; // (NA) Temporary Block Matrix for PCS modbus reading		
		AX_PcsHeartbit						: ARRAY [1..4] OF BOOL;
		                                	
		MesModbusReadAlarm 		  			: ARRAY [1..4] OF BOOL ;				// (NA) Modbus Read Alarm for communication
		TON_PcsHeartBitAlarm				: ARRAY [1..4] OF TON ;	
		TON_AlarmPcs						: ARRAY [1..4] OF TON ; 			// DesInhibate undervoltage alarms on PCS few seconds after PCS connected .  
                                        	
		DFV									: ARRAY[1..3] OF FB_DetectFixedValue;	
		StaticValuesToCompareHeartbit		: ARRAY[1..3] OF REAL;
		                                	                                     
		CTU_PcsNb							: CTU ; 
	

	// M_EVALUATE VARIABLES//
		DataHPP								: PP;
		DataPDL								: SUBMV_Exd;
		DataSystemBMS						: BAT;
		MesStatusWatchdog					: BOOL;
		MesHeartbeat_Old					: WORD;
		Trig_Watchdog						: R_TRIG;
		
	// Microcycling //
		MesMicroCyclingP					: REAL;				// (kW) Actual P for microcyling mode (if micro act = either ParamPmicro/-ParamPmicor, else 0)		
		MesMicroCyclingP_Old				: REAL;				// (kW) Active power the PCS will have during microcyling
	    MesMicroCyclingAllowed				: BOOL;				// (NA) If SoC is in range for microCycling                        		
		Trig_MicroCyclingNoLongerAllowed	: F_TRIG;			// Trig to detect falling edge of microcylingAllowed

	//M_WRITECOMMAND VARIABLES//    		
		ModbusWrite							: ARRAY [1..3] OF FB_ModbusWrite ;				// (NA) Functionnal Block for Writing Command Word through modbus
		Trig_Write							: ARRAY [1..3] OF R_TRIG;               		
		MesModbusWriteCmdAlarm				: ARRAY [1..3] OF BOOL ;						// (NA) Modbus Write Failed  (Command word) . 	
		MesModbusWriteCode          		: ARRAY [1..3] OF UDINT ; 						// (NA) Modbus Write Alarm Code 
		CmdWrite			AT%Q*			: ARRAY [1..3] OF BOOL;                     	
		AX_Cmd				AT%Q*			: ARRAY [1..3] OF ARRAY [1..120] OF WORD;   	
		AX_Cmd_Old							: ARRAY [1..3] OF ARRAY [1..120] OF WORD;   	
                                   		                                                	
		TRIG_CmdOpenAC						: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdOpenDC						: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdP_On						: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdQ_On			    		: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdCosPhi_On 					: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdP_Off						: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdQ_Off			    		: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdCosPhi_Off 					: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdBlackStart					: R_TRIG;										// Trig to detect an order to change Mode
		TRIG_CmdReset						: R_TRIG;		
		TRIG_FreqReg_On						: R_TRIG;
		TRIG_FreqReg_Off					: R_TRIG;
		TRIG_UReg_On						: R_TRIG;
		TRIG_UReg_Off						: R_TRIG;
		TRIG_CmdGridFormer					: R_TRIG;
		TRIG_CmdGridFeeder					: R_TRIG;
		TRIG_CmdMicroCyclingOn				: R_TRIG;
		TRIG_CmdMicroCyclingOff     		: R_TRIG;
		TRIG_CmdStop						: R_TRIG;
		TRIG_CmdStandby						: R_TRIG;
		TRIG_CmdStart						: R_TRIG;
		TRIG_CmdPcsLocal					: R_TRIG;
		TRIG_LowLowSoC						: R_TRIG;
		                            		
		TP_CmdBlackStart					: TP;				// TP To ensure R trig is detected
		TP_Reset							: TP ; 				// (NA) Maintain Reset command for a certain time 
		TP_CmdStandby						: TP;				// TP To maintain a soft stop order

		// Pour la commande start, j'envoie une consigne pour fermer les contacteurs DC des batteries
		TP_CmdOpenAC						: TP;				// TP To ensure R trig is detected
		TP_CmdOpenDC						: TP;				// TP To ensure R trig is detected

		TP_CmdStart							: TP;				// TP To ensure R trig is detected
		TP_CmdPreStart						: TP;				// TP To send a close dc breaker order before sending start order
		F_TrigPreStart						: F_TRIG;			// failing edge to detect end of TP;
		
		// Pour la commande stop, pour éviter qu'on ouvre tout d'un coup, je faire un pré stop pendant 1,5s où j'envoie un autre de standby
		TP_CmdStop							: TP;				// TP To ensure R trig is detected
		TP_CmdPreStop						: TP;				// TP to send a soft stop before sending a stop 
		F_TrigPreStop						: F_TRIG;			// failing edge to detect end of TP;
		                            		
		TON_CmdP_On							: TON;			// Trig to detect an order to change Mode
		TON_CmdQ_On			    			: TON;			// Trig to detect an order to change Mode
		TON_CmdCosPhi_On 					: TON;			// Trig to detect an order to change Mode
		TON_CmdP_Off						: TON;			// Trig to detect an order to change Mode
		TON_CmdQ_Off			    		: TON;			// Trig to detect an order to change Mode
		TON_CmdCosPhi_Off 					: TON;			// Trig to detect an order to change Mode
		TON_CmdBlackStart					: TON;			// Trig to detect an order to change Mode
		TON_FreqReg_On						: TON;
		TON_FreqReg_Off						: TON;
		TON_UReg_On							: TON;
		TON_UReg_Off						: TON;
		TON_CmdGridFormer					: TON;
		TON_CmdGridFeeder					: TON;
		TON_CmdMicroCyclingOn				: TON;
		TON_CmdMicroCyclingOff     			: TON;
		TON_CmdStart			    		: TON;
		TON_CmdStop	                		: TON;
		TON_CmdStandby		        		: TON;

		RS_hystlimitmin						: RS;
		RS_hystlimitmax						: RS;
 		RS_hystlimitEnergyShifmin			: RS;
		RS_hystlimitEnergyShifmax			: RS;
		
		CalPmaxCorr_highSoC					: REAL;
		CalPminCorr_lowSoC					: REAL;
        	           	                            		
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="M_AlarmManagement" Id="{89f05d6e-1339-4f9e-9c04-f4e3d271b595}">
      <Declaration><![CDATA[METHOD M_AlarmManagement
//////////////////
//  PCS Alarm Management 
/////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 
	FB_AlarmCodeManager : FB_AlarmCodeManager ; 
	KK					: UINT;				// For Loop
	ComWarning			: BOOL;				// Aggregated Wcommunication warning
	ComAlarm			: BOOL;				// Aggregated communication Alarm
	
	CalAlarmPcsSynthesis: BOOL;
	LL					: UINT;
	ID_Journal			: UINT;
	WordTest			: WORD;
	MesNbMots			: UINT;
END_VAR	
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// COMMUNICATION //
	ComWarning 				:=  MesModbusReadAlarm[1] OR MesModbusReadAlarm[2] OR MesModbusReadAlarm[3] ;		
	ComAlarm				:=  MesModbusReadAlarm[1] AND MesModbusReadAlarm[2] AND MesModbusReadAlarm[3]  ;
		
	TON_ComAlarm(IN:= ComAlarm , PT:= ParamTempoComAlarm, Q=>MesComAlarm) ;	
	TON_ComWarning(IN := ComWarning, PT := ParamTempoComWarning, Q => MesComWarning);
MesDataExd.MesData.MesComAlarm		:= MesComAlarm ; 
MesDataExd.MesData.MesComWarning 	:= MesComWarning ; 
	

// PCS ALARM INHIBITION
FOR KK := 1 TO ParamNbPcs DO
	TON_AlarmPcs[KK](IN:=NOT CalState.0, PT:= T#5S ) ;
	IF NOT TON_AlarmPcs[KK].Q THEN 
	MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.4 := FALSE ; 
	MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.7 := FALSE ; 
	MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.9 := FALSE ; 
	MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.11 := FALSE ; 
	MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.13 := FALSE ;			
	END_IF
	
	DFV[KK](IN_Addr := ADR(MesDataExd.MesData.AX_PowerCol[KK].MesHeartbit), IN_EmptyStruct := ADR(StaticValuesToCompareHeartbit[KK]) , IN_Size := SIZEOF(MesDataExd.MesData.AX_PowerCol[KK].MesHeartbit), IN_Duration := T#10S, OUT_bStatic => AX_PcsHeartbit[KK] ) ; 
	
END_FOR	


// SYNTHESES ALARMES //
CalAlarmPcsSynthesis := MesDataExd.MesData.AX_PowerCol[1].MesRegAlarm0 > 0
OR MesDataExd.MesData.AX_PowerCol[2].MesRegAlarm0 > 0
OR MesDataExd.MesData.AX_PowerCol[3].MesRegAlarm0 > 0
OR MesDataExd.MesData.AX_PowerCol[1].MesRegAlarm1 > 0
OR MesDataExd.MesData.AX_PowerCol[2].MesRegAlarm1 > 0
OR MesDataExd.MesData.AX_PowerCol[3].MesRegAlarm1 > 0
OR MesDataExd.MesData.AX_PowerCol[1].MesRegAlarm2 > 0
OR MesDataExd.MesData.AX_PowerCol[2].MesRegAlarm2 > 0
OR MesDataExd.MesData.AX_PowerCol[3].MesRegAlarm2 > 0
OR MesDataExd.MesData.AX_PowerCol[1].MesRegAlarm3 > 0
OR MesDataExd.MesData.AX_PowerCol[2].MesRegAlarm3 > 0
OR MesDataExd.MesData.AX_PowerCol[3].MesRegAlarm3 > 0
OR MesDataExd.MesData.AX_PowerCol[1].MesRegAlarm4 > 0
OR MesDataExd.MesData.AX_PowerCol[2].MesRegAlarm4 > 0
OR MesDataExd.MesData.AX_PowerCol[3].MesRegAlarm4 > 0 ;


// AlarmCode		
	FB_AlarmCodeManager(
		bAlarm1		:= CalAlarmPcsSynthesis		,								// Power columns Alarm Synthesis, at least one alarm active on power column
		bAlarm2		:= TON_CmdP_On.Q OR TON_CmdP_Off.Q,							// Timeout for CmdP order
		bAlarm3		:= TON_CmdQ_On.Q OR TON_CmdQ_Off.Q,							// Timeout for CmdQ order			
		bAlarm4		:= FALSE,										            //                              			    	
		bAlarm5		:= TON_CmdBlackStart.Q,                                     // Timeout for BlackStart order   			
		bAlarm6		:= TON_FreqReg_On.Q OR TON_FreqReg_Off.Q,                   // Timeout for Freq Regulation activation                            				
		bAlarm7		:= TON_UReg_On.Q OR TON_UReg_Off.Q,                         // Timeout for Voltage Regulation activation
		bAlarm8 	:= TON_CmdGridFormer.Q,                                     // Timeout for grid former activation
		bAlarm9		:= TON_CmdGridFeeder.Q,                                     // Timeout for grid feeder activation
		bAlarm10	:= TON_CmdMicroCyclingOn.Q OR TON_CmdMicroCyclingOff.Q,     // Timeout for MicroCycling
		bAlarm11	:= MesDataExd.MesData.MesComAlarm,                                     // Communication alarm : none of the Power Columns are responding 				
		bAlarm12	:= FALSE,                                               	//				
		bAlarm13	:= FALSE,                                               	//			
		bAlarm14	:= FALSE,                                               	//		
		bAlarm15	:= FALSE,                                               	//		
		wAlarmCode	=>MesDataExd.MesData.MesAlarmCode);		                                		
		                                                                                 	
		
		
// WARNING CODE //
	FB_AlarmCodeManager(
		bAlarm1		:= MesComWarning, 																															// Communication warning : At least one of the Power Columns are not responding 
		bAlarm2		:= FALSE,																																	// 
		bAlarm3		:= MesDataExd.MesData.AX_PowerCol[1].MesDeratingWord.0  ,  																							// Power Column 1 derating active due to temperature
		bAlarm4		:= MesDataExd.MesData.AX_PowerCol[2].MesDeratingWord.0,    																							// Power Column 2 derating active due to temperature
		bAlarm5		:= MesDataExd.MesData.AX_PowerCol[3].MesDeratingWord.0,  																								// Power Column 3 derating active due to temperature
		bAlarm6		:= MesDataExd.MesData.AX_PowerCol[1].MesDeratingWord.4 OR MesDataExd.MesData.AX_PowerCol[2].MesDeratingWord.4 OR MesDataExd.MesData.AX_PowerCol[3].MesDeratingWord.4,      	// At least one power column has a derating due to overvoltage
		bAlarm7		:= MesDataExd.MesData.AX_PowerCol[1].MesDeratingWord.5 OR MesDataExd.MesData.AX_PowerCol[2].MesDeratingWord.5 OR MesDataExd.MesData.AX_PowerCol[3].MesDeratingWord.5,      	// At least one power column has a derating due to undervoltage
		bAlarm8		:= MesDataExd.MesData.AX_PowerCol[1].MesDeratingWord.6 OR MesDataExd.MesData.AX_PowerCol[2].MesDeratingWord.6 OR MesDataExd.MesData.AX_PowerCol[3].MesDeratingWord.6,      	// At least one power column has a derating due to overfrequency
		bAlarm9		:= MesDataExd.MesData.AX_PowerCol[1].MesDeratingWord.7 OR MesDataExd.MesData.AX_PowerCol[2].MesDeratingWord.7 OR MesDataExd.MesData.AX_PowerCol[3].MesDeratingWord.7,      	// At least one power column has a derating due to underfrequency
		bAlarm10	:= MesDataExd.MesData.AX_PowerCol[1].MesDoorOpened,           																							// Power column 1 cabinet door is opened
		bAlarm11	:= MesDataExd.MesData.AX_PowerCol[2].MesDoorOpened,           																							// Power column 2 cabinet door is opened
		bAlarm12	:= MesDataExd.MesData.AX_PowerCol[3].MesDoorOpened,           																							// Power column 3 cabinet door is opened
		bAlarm13	:= FALSE,           																														//
		bAlarm14	:= FALSE,           																														//
		bAlarm15	:= FALSE,           																														//
		wAlarmCode	=>MesDataExd.MesData.MesWarningCode);
		
// EVENT CODE //
	FB_AlarmCodeManager(
		bAlarm1			:= MesDataExd.MesData.AX_PowerCol[1].MesAcSwitchClosed,																							// AC Switch Closed for PCS 1
		bAlarm2			:= NOT MesDataExd.MesData.MesDcBreaker, 																											// DC Switch Closed
		bAlarm3			:= MesDataExd.MesData.OUT_CmdStandby, 																												// Soft stop command
		bAlarm4			:= MesDataExd.MesData.MesOnGrid,																													// OnGrid Mode is activated
		bAlarm5			:= MesDataExd.MesData.MesOffGrid, 																													// Offgrid Mode is activated
		bAlarm6			:= MesDataExd.MesData.OUT_CmdStart, 																												// Cmd Start
		bAlarm7			:= MesDataExd.MesData.OUT_CmdStop, 																												// Full stop command
		bAlarm8			:= MesDataExd.MesData.OUT_CmdBlackStart, 																											// Cmd BlackStart
		bAlarm9			:= MesDataExd.MesData.AX_PowerCol[1].MesRegAlarm2.9 OR MesDataExd.MesData.AX_PowerCol[2].MesRegAlarm2.9 OR MesDataExd.MesData.AX_PowerCol[3].MesRegAlarm2.9,			// Grid collapsed 
		bAlarm10		:= MesDataExd.MesData.AX_PowerCol[2].MesAcSwitchClosed,																							// AC Switch Closed for PCS 2
		bAlarm11		:= SEL(ParamNbPcs>2 ,  FALSE, MesDataExd.MesData.AX_PowerCol[3].MesAcSwitchClosed),																// AC Switch Closed for PCS 3
		bAlarm12		:= NOT MesDataExd.MesData.MesAcBreaker, 																											// Ac breaker is Closed. 
		bAlarm13		:= MesDataExd.MesData.MesPrecharge,                                                                                            					// ESS - INV : Precharge
		bAlarm14		:= NOT MesDataExd.MesData.OUT_CmdGridMode,                                                                                                         // OnGrid command
		bAlarm15		:= MesDataExd.MesData.OUT_CmdGridMode, 																											// OffGrid command
		wAlarmCode		=>MesDataExd.MesData.MesEventCode);                                                                                           					// 
		

NumAlarmsActive := 0;
AX_AlarmWords := AX_AlarmWords_Null;
MesNbMots := 2;
FOR KK := 1 TO MesNbMots DO			// Combien j'ai de mots
	ID_Journal := 15 + (ParamEssNum-1) * MesNbMots * CstNbPcs_ESS_G + (ParamPcsNum - 1) * CstNbPcs_ESS_G + (KK- 1);
	FOR LL := 1 TO 15 DO 	// Les bits 
		WordTest := ROR(FUN_Alarms.AX_RecupWord[ID_Journal],LL);
		IF WordTest.0 THEN
			NumAlarmsActive := NumAlarmsActive + 1;
			AX_AlarmWords[NumAlarmsActive].Message := FUN_Alarms.AX_Journal[ID_Journal][LL].Message;
		ELSE
			AX_AlarmWords[NumAlarmsActive+1].Message := '';
		END_IF
	END_FOR
END_FOR		

NumAlarmsActiveJema := 0;
AX_AlarmWordsJema := AX_AlarmWordsJema_Null;
MesNbMots := 15;
FOR KK := 1 TO MesNbMots DO			// Combien j'ai de mots
	FOR LL := 1 TO 15 DO 	// Les bits 
		ID_Journal := 57 + (ParamEssNum-1) * MesNbMots * CstNbPcs_ESS_G + (ParamPcsNum - 1) * CstNbPcs_ESS_G + (KK- 1);
		WordTest := ROR(FUN_Alarms.AX_RecupWord[ID_Journal],LL);
		IF WordTest.0 THEN
			NumAlarmsActiveJema := NumAlarmsActiveJema + 1;
			AX_AlarmWordsJema[NumAlarmsActiveJema].Message := FUN_Alarms.AX_Journal[ID_Journal][LL].Message;
		ELSE
			AX_AlarmWordsJema[NumAlarmsActiveJema+1].Message := '';
		END_IF
	END_FOR
END_FOR		
		
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_CP" Id="{6ed0a219-42a8-4352-a6ce-2534d4d4a775}">
      <Declaration><![CDATA[METHOD M_CP
//////////////////
//  Emulator
/////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.M_CP();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Evaluate" Id="{70c7db13-1835-44c2-ac84-41f013391d07}">
      <Declaration><![CDATA[METHOD M_Evaluate : BOOL
VAR_INPUT
END_VAR
VAR
	KK : UINT;
	bTest: BOOL;
	MesAlarmPcs: BOOL;
	AX_Journal : ARRAY[57..57] of array[1..15] of ST_ValuesAlarms;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// External values update :
DataHPP			:= A1_PP.MesDataExd.MesData.
DataSystemBMS 	:= AX_ESS[ParamEssNum].AX_BAT[ParamPcsNum].MesDataExd.MesData.
DataPDL 		:= A1_SUBMV.MesDataExd.MesData.

Trig_Watchdog(CLK := MesHeartbeat_Old <>MesDataExd.MesData.MesHeartBeat);
IF Trig_Watchdog.Q 	THEN
	MesHeartbeat_Old := MesDataExd.MesData.MesHeartBeat;
	MesStatusWatchdog := NOT MesStatusWatchdog;
END_IF

// PROPERTIES UPDATE // 
	// Controller
MesDataExd.MesData.MesP 	:= 0 ; 
MesDataExd.MesData.MesPdc 	:= 0 ;
MesDataExd.MesData.MesQ 	:= 0 ; 
MesDataExd.MesData.MesI 	:= 0 ; 			
MesDataExd.MesData.MesIdc 	:= 0 ; 		


MesDataExd.MesData.MesComAlarm					:= TRUE ; 						// All PCS in Com alarm . 			
MesDataExd.MesData.MesAtLeastOnePcsConnected 	:= FALSE  ; 	// At least one inverter connected and not in alarm			
MesDataExd.MesData.MesFreqReg_Active 			:= FALSE;
MesDataExd.MesData.MesUReg_Active 				:= FALSE;

	// Update PCS Values	
	FOR KK:= 1 TO ParamNbPcs DO 
	MesDataExd.MesData.MesP 						:= MesDataExd.MesData.AX_PowerCol[KK].MesP + MesDataExd.MesData.MesP  ; 
	MesDataExd.MesData.MesI 						:= MesDataExd.MesData.AX_PowerCol[KK].MesI + MesDataExd.MesData.MesI  ; 
	MesDataExd.MesData.MesPdc 						:= MesDataExd.MesData.AX_PowerCol[KK].MesPdc + MesDataExd.MesData.MesPdc  ; 
		// ATTENTION MODIF RELATIVE A JEMA, JE METS UN MOINS PSK ILS SONT CONS
	MesDataExd.MesData.MesQ 						:= -.MesDataExd.MesData.AX_PowerCol[KK].MesQ + MesDataExd.MesData.MesQ  ; 
	MesDataExd.MesData.MesIdc 						:= MesDataExd.MesData.AX_PowerCol[KK].MesIdc + MesDataExd.MesData.MesIdc  ; 
	MesDataExd.MesData.MesFreqReg_Active			:= MesDataExd.MesData.MesFreqReg_Active 			OR MesDataExd.MesData.AX_PowerCol[KK].MesDeratingWord.6 OR MesDataExd.MesData.AX_PowerCol[KK].MesDeratingWord.7 ;
	MesDataExd.MesData.MesUReg_Active				:= MesDataExd.MesData.MesUReg_Active 				OR MesDataExd.MesData.AX_PowerCol[KK].MesDeratingWord.4 OR MesDataExd.MesData.AX_PowerCol[KK].MesDeratingWord.5 ;
		MesAlarmPcs							:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0 > 0 OR MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1 > 0 	OR MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2 > 0 OR MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3 > 0 OR MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm4 > 0);                                        	
	MesDataExd.MesData.MesComAlarm					:= MesDataExd.MesData.MesComAlarm 					AND AX_PcsHeartbit[KK];
	MesDataExd.MesData.MesAtLeastOnePcsConnected 	:= MesDataExd.MesData.MesAtLeastOnePcsConnected 	OR MesDataExd.MesData.AX_PowerCol[KK].MesAcSwitchClosed (*FAT TESTAND NOT MesAlarmPcs *);
		


		
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesI1_Alm					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.0;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesI2_Alm					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.1;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesI3_Alm					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.2;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesVdc_High_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.3;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesVdc_Low_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.4;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesU12_High_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.6;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesU12_Low_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.7;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesU23_High_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.8;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesU23_Low_Alm	 		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.9;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesU31_High_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.10;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesU31_Low_Alm	 		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.11;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesVd_High_Alm			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.12;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesVd_Low_Alm				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.13;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesVdc_Neg				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm0.14;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesU1223_Unbalance		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.0;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesU2331_Unbalance		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.1;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesU3112_Unbalance		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.2;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesInvertedPhase			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.3;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesI12_Unbalance			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.4;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesI23_Unbalance			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.5;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesI31_Unbalance			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.6;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesCouplingTimeout		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.7;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesF_High					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.8;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesF_Low			 		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.9;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesGrndFault				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.10;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesVaristor		 		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.11;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesPcbOverTemp			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.12;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesHeatsinkOverTemp		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.13;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesOvertempHyst			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm1.15;		
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesGridCbOpened			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.4;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesGridCbTrip				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.5;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesGridContactFail		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.8;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesDoorOpened				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.9;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesVdcPrechargewrong		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.12;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesOverVoltHyst			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.14;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesIdcMax					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm2.15;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesSKIIP1					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.0;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesSKIIP2					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.1;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesSKIIP3					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.2;
	MesDataExd.MesData.AX_PowerCol[KK].MesJemaAlarms.MesSKIIP_OT				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.3;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesIMax					:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.4;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesEmergencyStop			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.5;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesFPGA_WdogTrip			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.6;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesStopEverything			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.7;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesImdWarning				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.8;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesImdFault				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.9;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesCoilOverTemp			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.11;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesAlrmGrp1_Curr			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.13;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesAlrmGrp2_Curr	 		:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.14;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesShortCircuit_DC	 	:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm3.15;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesBatError				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm4.0;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesBatCtlStop				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm4.1;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesBatComErrors			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm4.2;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesPowerUnbalance			:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm4.3;
	MesDataExd.MesData.AX_PowerCol[KK].MesjemaAlarms.MesOverpower				:= MesDataExd.MesData.AX_PowerCol[KK].MesRegAlarm4.4;

		
	END_FOR 
	
MesDataExd.MesData.MesCosPhi 				:= SEL(	MesDataExd.MesData.MesP=0) AND  MesDataExd.MesData.MesQ =0 ), MesDataExd.MesData.MesP / SQRT(EXPT.MesDataExd.MesData.MesP, 2) + EXPT.MesDataExd.MesData.MesQ, 2))   , 1) ; 		
MesDataExd.MesData.MesFreq					:= SEL.MesDataExd.MesData.AX_PowerCol[1].MesFreq=0 MesDataExd.MesData.AX_PowerCol[1].MesFreq , SEL.MesDataExd.MesData.AX_PowerCol[2].MesFreq=0 MesDataExd.MesData.AX_PowerCol[2].MesFreq MesDataExd.MesData.AX_PowerCol[3].MesFreq ))   ; 		
MesDataExd.MesData.MesU 					:= SEL.MesDataExd.MesData.AX_PowerCol[1].MesU=0 MesDataExd.MesData.AX_PowerCol[1].MesU , SEL.MesDataExd.MesData.AX_PowerCol[2].MesU=0 MesDataExd.MesData.AX_PowerCol[2].MesU MesDataExd.MesData.AX_PowerCol[3].MesU ))   ; 		
MesDataExd.MesData.MesUdc 					:= SEL.MesDataExd.MesData.AX_PowerCol[1].MesUdc=0 MesDataExd.MesData.AX_PowerCol[1].MesUdc , SEL.MesDataExd.MesData.AX_PowerCol[2].MesUdc=0 MesDataExd.MesData.AX_PowerCol[2].MesUdc MesDataExd.MesData.AX_PowerCol[3].MesUdc ))   ; 			
	 
//--------------------------------------------------------------------------------//
// 							Gestion des setpoints								  //
//--------------------------------------------------------------------------------//
	
// Gestion de la puissance dispo batterie		
	/  MesDataExd.MesData.CalDynamicEfficiencyPcs := (ParamRendementPcsNom  - ParamRendementPcsMin)* (1-EXP(-(abs.MesDataExd.MesData.CalP)/ParamPnom)*100/ParamTauxDeChargeRef)) + ParamRendementPcsMin;

// Gestion des limites hautes de SoC
	RS_hystlimitmax(SET:= DataSystemBMS.MesSoCConnected>= A1_PP.ParamSocMax_G , RESET1:= DataSystemBMS.MesSoCConnected< A1_PP.ParamSocVeryHigh) ; 
	RS_hystlimitmin(SET:= DataSystemBMS.MesSoCConnected<= A1_PP.ParamSocMin_G , RESET1:= DataSystemBMS.MesSoCConnected> A1_PP.ParamSocVeryLow) ; 
	
	IF DataSystemBMS.MesSoCConnected >= ParamSocVeryHigh THEN
		CalPmaxCorr_highSoC := (A1_PP.ParamSocMax_G - DataSystemBMS.MesSoCConnected)/(A1_PP.ParamSocMax_G - A1_PP.ParamSocVeryHigh );
	ELSE 
		CalPmaxCorr_highSoC := 1 ;
	END_IF 
	IF DataSystemBMS.MesSoCConnected <= ParamSocMin_L THEN
	CalPminCorr_lowSoC := (A1_PP.ParamSocMin_G - DataSystemBMS.MesSoCConnected)/(A1_PP.ParamSocMin_G - A1_PP.ParamSocVeryLow );
	ELSE
		CalPminCorr_lowSoC := 1;
	END_IF
	IF (datasystembms.MesCCL <> 0 OR datasystembms.MesDCL <> 0) AND DataSystemBMS.MesUdcConnected <> 0 THEN
	MesDataExd.MesData.MesS_BatChargeMax 		:=  SEL(RS_hystlimitmax.Q1, 1, 0) * CalPmaxCorr_highSoC * MIN(DataSystemBMS.MesCCL* DataSystemBMS.MesNbRackConnected,	ParamPnom);
	MesDataExd.MesData.MesS_BatDischargeMax 	:=  SEL(RS_hystlimitmin.Q1, 1, 0) * CalPminCorr_lowSoC * MIN(DataSystemBMS.MesDCL* DataSystemBMS.MesNbRackConnected,	ParamPnom);
	ELSE
	MesDataExd.MesData.MesS_BatChargeMax := 0;
	MesDataExd.MesData.MesS_BatDischargeMax := 0;
	END_IF

// Local
	// Si je suis en local, je désactive le micro cycling et je réecris le setpoint d'input	
	IF MesDataExd.MesData.OUT_CmdInvLocal THEN
	MesDataExd.MesData.OUT_CmdMicroCyclingMode := FALSE;
		IN_SetptP := IN_SetptP_Local;
		IN_SetptQ := IN_SetptQ_Local;
		IN_SetptU := IN_SetptU_Local;
		IN_SetptF := IN_SetptF_Local;
	END_IF

// MicroCycling
	// j'évalue si j'ai le droit de faire du micro-cycling
	MesMicroCyclingAllowed := DataSystemBMS.MesSoC >= ParamMicroCyclingSoCMin*0.95 AND DataSystemBMS.MesSoC <= ParamMicroCyclingSoCMax*1.05 ;
	Trig_MicroCyclingNoLongerAllowed(CLk := MesMicroCyclingAllowed);

	// Si je suis en mode micro cycling, dès que je passe au dessus du soc max, je décharge la batterie
	IF MesDataExd.MesData.OUT_CmdMicroCyclingMode AND DataSystemBMS.MesSoC >= ParamMicroCyclingSoCMax THEN
		IN_SetptP := ABS(ParamMicroCyclingPower);
	END_IF
	// Sinon, je la recharge
	IF MesDataExd.MesData.OUT_CmdMicroCyclingMode AND DataSystemBMS.MesSoC <= ParamMicroCyclingSoCMin THEN
		IN_SetptP := -ABS(ParamMicroCyclingPower);
	END_IF

	// et si je vois que la puissance de consigne change, je la réecris (en gardant le bon sens charge/décharge)
	IF MesMicroCyclingP_Old <> ParamMicroCyclingPower THEN
		MesMicroCyclingP_Old := ParamMicroCyclingPower;
		IN_SetptP := SEL(IN_SetptP > 0, -ABS(ParamMicroCyclingPower), ABS(ParamMicroCyclingPower));
	END_IF

IF ParamPoverQ THEN 
	// Le setpoint Max correspond à la dispo * la puissance nominale
MesDataExd.MesData.OUT_SetptPMax := MIN(MesDataExd.MesData.MesS_BatDischargeMax, MesDataExd.MesData.MesAvailability * MesDataExd.MesData.MesSnom/100.0,  SEL(DataSystemBMS.MesSoCConnected <= A1_PP.ParamSocMin_G, ParamPnom, 0));
MesDataExd.MesData.OUT_SetptPMin := MAX( MesDataExd.MesData.MesS_BatChargeMax, MesDataExd.MesData.MesAvailability * MesDataExd.MesData.MesSnom/100.0, SEL(DataSystemBMS.MesSoCConnected >= A1_PP.ParamSocMax_G, -ParamPnom, 0));

	// Min
	IF ABS.MesDataExd.MesData.MesS_BatDischargeMax) > ABS.MesDataExd.MesData.OUT_SetptP) THEN
	MesDataExd.MesData.OUT_SetptQMax		:= SQRT(EXPT.MesDataExd.MesData.MesS_BatDischargeMax, 2) - EXPT.MesDataExd.MesData.OUT_SetptP, 2));
	ELSE
	MesDataExd.MesData.OUT_SetptQMin := 0;
	END_IF
	IF ABS.MesDataExd.MesData.MesS_BatChargeMax) > ABS.MesDataExd.MesData.OUT_SetptP) THEN
	MesDataExd.MesData.OUT_SetptQMin		:= -SQRT(EXPT.MesDataExd.MesData.MesS_BatChargeMax, 2) - EXPT.MesDataExd.MesData.OUT_SetptP, 2));
	ELSE 
	MesDataExd.MesData.OUT_SetptQMin := 0;
	END_IF
ELSE
MesDataExd.MesData.OUT_SetptQMax := SEL.MesDataExd.MesData.MesP = 0, SEL.MesDataExd.MesData.MesP>0, MesDataExd.MesData.MesS_BatChargeMax, MesDataExd.MesData.MesS_BatDischargeMax), MIN(MesDataExd.MesData.MesS_BatChargeMax.MesDataExd.MesData.MesS_BatDischargeMax));
MesDataExd.MesData.OUT_SetptQMin := -.MesDataExd.MesData.OUT_SetptQMax;
	
MesDataExd.MesData.OUT_SetptPMax		:= MIN(SQRT(EXPT.MesDataExd.MesData.MesS_BatChargeMax, 2) - EXPT.MesDataExd.MesData.OUT_SetptQ, 2)),  SEL(DataSystemBMS.MesSoCConnected < A1_PP.ParamSocMin_G, ParamPnom, 0));
MesDataExd.MesData.OUT_SetptPMin		:= MAX(SQRT(EXPT.MesDataExd.MesData.MesS_BatDischargeMax, 2) - EXPT.MesDataExd.MesData.OUT_SetptQ, 2)),  SEL(DataSystemBMS.MesSoCConnected > A1_PP.ParamSocMax_G, ParamPnom, 0));
END_IF

// J'affecte les variables que je vais écrire
IF MesDataExd.MesData.OUT_CmdP THEN
MesDataExd.MesData.OUT_SetptP		:= MIN(MAX(IN_SetptP, MesDataExd.MesData.OUT_SetptPMin), MesDataExd.MesData.OUT_SetptPMax);
ELSE
MesDataExd.MesData.OUT_SetptP 		:= 0;
END_IF

IF MesDataExd.MesData.OUT_CmdQ THEN
MesDataExd.MesData.OUT_SetptQ		:= -MIN(MAX(IN_SetptQ, MesDataExd.MesData.OUT_SetptQMin), MesDataExd.MesData.OUT_SetptQMax);
ELSE
MesDataExd.MesData.OUT_SetptQ 		:= 0;
END_IF

MesData.OUT_SetptV := IN_SetptU;
MesData.OUT_SetptF := IN_SetptF;


TON_CmdQ_On				(IN := MesDataExd.MesData.OUT_CmdQ 					AND NOT MesDataExd.MesData.MesOpeFlag.4, PT := ParamTimeoutCmdQ);		
TON_CmdCosPhi_On		(IN := MesDataExd.MesData.OUT_CmdCosPhi 				AND NOT MesDataExd.MesData.MesOpeFlag.5, PT := ParamTimeoutCmdCosPhi);		
TON_CmdQ_Off			(IN :=  NOT MesDataExd.MesData.OUT_CmdQ  				AND MesDataExd.MesData.MesOpeFlag.4, PT := ParamTimeoutCmdQ);				   	
TON_CmdCosPhi_Off		(IN :=  NOT MesDataExd.MesData.OUT_CmdCosPhi 			AND MesDataExd.MesData.MesOpeFlag.5, PT := ParamTimeoutCmdCosPhi);		
TON_CmdBlackStart		(IN := MesDataExd.MesData.OUT_CmdBlackStart 			AND NOT MesDataExd.MesData.MesOpeFlag.8, PT := ParamTimeOutBlckStrt);
TON_FreqReg_On			(IN := MesDataExd.MesData.OUT_CmdFreqregMode 			AND NOT MesDataExd.MesData.MesOpeFlag.2, PT := ParamTimeoutPvF);			
TON_FreqReg_Off			(IN :=  NOT MesDataExd.MesData.OUT_CmdFreqregMode 		AND MesDataExd.MesData.MesOpeFlag.2, PT := ParamTimeoutPvF	);		
TON_UReg_On				(IN := MesDataExd.MesData.OUT_CmdUregMode 			AND NOT MesDataExd.MesData.MesOpeFlag.1, PT := ParamTimeoutQvU	);		
TON_UReg_Off			(IN :=  NOT MesDataExd.MesData.OUT_CmdUregMode 		AND MesDataExd.MesData.MesOpeFlag.1, PT := ParamTimeoutQvU	);		
TON_CmdGridFormer		(IN := MesDataExd.MesData.OUT_CmdGridMode 			AND NOT MesDataExd.MesData.MesOpeFlag.10, PT := ParamTimeoutGridFormerTransition	);		
TON_CmdGridFeeder		(IN :=  NOT MesDataExd.MesData.OUT_CmdGridMode			AND MesDataExd.MesData.MesOpeFlag.10, PT := ParamTimeoutGridFeederTransition	);		
TON_CmdStop				(IN := MesDataExd.MesData.OUT_CmdStop					AND MesDataExd.MesData.MesState.0);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{e27e0f9c-3814-401c-b800-e9515e1f91b9}">
      <Declaration><![CDATA[METHOD M_Init

VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.M_Init() ; 

MesData.OUT_CmdP := TRUE;
MesData.OUT_CmdQ := TRUE;

MesCP_Read := TRUE;
MesCP_Write := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Read" Id="{2d1106ff-e1b7-4ce2-89be-a416fc957482}">
      <Declaration><![CDATA[METHOD M_Read
//////////////////
//  Read Modbus Variable for PCS . 
/////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 
	MW 						: FB_MergeWordsToDint; 

	
	MesPsetPt_Temp 			: REAL ;
	MesQsetPt_Temp			: REAL ;
	MesPavailablePcs_Temp	: REAL;
	MesPavailable_Temp		: REAL;
	
	ComErrorPcs_Temp		: WORD;
	
	KK						: BYTE;  					// FOR Loop 
	LL						: BYTE;						// Alarm Loop

	MesPsetPtPcs_temp		: ARRAY[1..CstNbPcs_ESS_G] OF  REAL; // Setpt lu sur le module
	MesQsetPtPcs_temp		: ARRAY[1..CstNbPcs_ESS_G] OF  REAL;

	AX_Qty					: ARRAY[1..3] OF WORD := [75, 68, 68];
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// CP-Read / Write 

MesDataExd.MesData.MesCP_Read := MesCP_Read ; 
MesDataExd.MesData.MesCP_Write := MesCP_Write ;  

IF MesCP_Read  THEN	
// MODBUS REQUEST//

		ModbusRead[4]
		(
			tTimeout		:= ParamTimeout,
			nUnitID			:= ParamUnitID,
			sIPAddr			:= ParamIPAddress ,
			ClockRead		:= ClockRead AND MesCP_Read,
			nTcpPort		:= ParamTcpPort,
			nQuantity		:= 75,
			Reset			:= IN_CmdReset,
			nMBAddr			:= 1100  ,//Access every PCS power modules
			cbLength		:= SIZEOF(MesBlock1_Temp[4]) , 
			pDestAddr		:= ADR(MesBlock1_Temp[4]),
			ModbusReadAlarm	=>MesModbusReadAlarm[4]
		);
    
		
		
		
// MODBUS REQUEST//
	FOR KK:=1 TO ParamNbPcs DO 	
		ModbusRead[KK]
		(
			tTimeout		:= ParamTimeout,
			nUnitID			:= ParamUnitID,
			sIPAddr			:= ParamIPAddress_DSP[KK] ,
			ClockRead		:= ClockRead AND MesCP_Read,
			nTcpPort		:= ParamTcpPort,
			nQuantity		:= AX_Qty[KK],
			Reset			:= IN_CmdReset,
			nMBAddr			:= 1000 ,
			cbLength		:= SIZEOF(MesBlock1_Temp[KK]) , 
			pDestAddr		:= ADR(MesBlock1_Temp[KK]),
			ModbusReadAlarm	=>MesModbusReadAlarm[KK]
		);
    
	END_FOR

	
	
	
// MODBUS BLOCK SEPARATION/
	// Block1 (PCS) 
	FOR KK:=1 TO ParamNbPcs DO 	// Value per Power Column (3 per inverter IBX3)
		// Measurements
		MW( WORD_STRONG:= MesBlock1_Temp[KK][1], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesUdc); 
		MW( WORD_STRONG:= MesBlock1_Temp[KK][2], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesIdc); //Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][3], SIGNED:=FALSE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesU);
		MW( WORD_STRONG:= MesBlock1_Temp[KK][6], SIGNED:=FALSE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesI1); //Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][7], SIGNED:=FALSE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesI2); //Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][8], SIGNED:=FALSE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesI3); //Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][9], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesPdc); // Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][10], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesP); // Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][11], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesQ);// Vérifier les signes
		MW( WORD_STRONG:= MesBlock1_Temp[KK][12], SIGNED:=FALSE, FIX:=3 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesCosPhi);
		MW( WORD_STRONG:= MesBlock1_Temp[KK][13], SIGNED:=FALSE, FIX:=2 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesFreq);
		
		// Inputs (Temp and IO)
		MW( WORD_STRONG:= MesBlock1_Temp[KK][15], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesTempControl);
		MW( WORD_STRONG:= MesBlock1_Temp[KK][18], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesTempPowerUnit);

		// Alarms
	MesDataExd.AX_PowerCol[KK].MesRegAlarm0:=MesBlock1_Temp[KK][24];
	MesDataExd.AX_PowerCol[KK].MesRegAlarm1:=MesBlock1_Temp[KK][25];
	MesDataExd.AX_PowerCol[KK].MesRegAlarm2:=MesBlock1_Temp[KK][26];
	MesDataExd.AX_PowerCol[KK].MesRegAlarm3:=MesBlock1_Temp[KK][27];
	MesDataExd.AX_PowerCol[KK].MesRegAlarm4:=MesBlock1_Temp[KK][28];					

		MW( WORD_STRONG:= MesBlock1_Temp[KK][48], SIGNED:=TRUE, FIX:=1 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesTempCabinet);
		
		// States
	MesDataExd.AX_PowerCol[KK].MesAcSwitchClosed := MesBlock1_Temp[KK][61].2 ;	// AC contactor status
	MesDataExd.AX_PowerCol[KK].MesDoorOpened := NOT MesBlock1_Temp[KK][61].6; // Door : 1= Close, O= Open
	MesDataExd.AX_PowerCol[KK].MesDeratingWord := MesBlock1_Temp[KK][62] ;
		
		MW( WORD_STRONG:= MesBlock1_Temp[KK][68], SIGNED:=FALSE, FIX:=0 , SIZE:=1, VAR_OUT := MesDataExd.AX_PowerCol[KK].MesHeartbit);
		

	END_FOR

	// Inverter states (à tester)

MesDataExd.MesData.MesOpeFlag					:= MesBlock1_Temp[4][67];
MesDataExd.MesData.MesSnom						:= ParamSmax;		//MàJ : WORD_TO_REAL(MesBlock1_Temp[1][69]);
MesDataExd.MesData.MesAvailability				:= WORD_TO_REAL(MesBlock1_Temp[4][70]);
	
	MW( WORD_STRONG := MesBlock1_Temp[4][71], SIZE := 1, FIX := 0, SIGNED := FALSE, VAR_OUT := MesDataExd.MesData.MesHumidity);
	MW( WORD_STRONG := MesBlock1_Temp[4][72], SIZE := 1, FIX := 1, SIGNED := TRUE, VAR_OUT := MesDataExd.MesData.MesTemp);
	
MesDataExd.MesData.MesPrecharge 				:= WORD_TO_BOOL(MesBlock1_Temp[4][73]);
MesDataExd.MesData.MesDcBreaker				:= MesBlock1_Temp[4][74].0;
MesDataExd.MesData.MesAcBreaker				:= MesBlock1_Temp[4][61].0;
MesDataExd.MesData.MesSoCLimitReached			:= MesBlock1_Temp[4][74].2;
MesDataExd.MesData.MesOffGrid					:= MesBlock1_Temp[4][74].3;
MesDataExd.MesData.MesOnGrid					:= MesBlock1_Temp[4][74].4;
MesDataExd.MesData.MesHeartBeat				:= MesBlock1_Temp[4][75];
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StateManager" Id="{fa2ecaf2-d096-498d-9414-0360ec10edda}">
      <Declaration><![CDATA[METHOD M_StateManager
//////////////////
// Detect which is the state of the PCS system . 
/////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 

	
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[ MesDataExd.MesData.MesState 		:= 0;



IF NOT MesDataExd.MesData.MesAcBreaker AND NOT MesDataExd.MesData.MesDcBreaker THEN 
	// OFF State :  No Charger connected or all charger in alarm
MesDataExd.MesData.MesState.0 	:= 1 ; 
	
ELSIF MesDataExd.MesData.MesOffGrid THEN
	// Feeding master
MesDataExd.MesData.MesState.1 	:= 1 ; 
	
ELSIF MesDataExd.MesData.MesOnGrid THEN
	// Feeding slave
MesDataExd.MesData.MesState.2 	:= 1 ; 
	
END_IF

SUPER^.M_StateManager() ; ]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_WriteCommand" Id="{d4ee2a88-ca9f-4d95-97ac-a23da3795a20}">
      <Declaration><![CDATA[METHOD M_WriteCommand
//////////////////
//  Modbus Write of the command for the PCS. 
/////////////////

VAR 
	// Method local variables (reinitialized at each cycle) 
	
	AX_Adr			: ARRAY[1..3] OF UINT := [1707	, 1802	, 	0217	];
	AX_QTY			: ARRAY[1..3] OF BYTE := [40	, 33	, 	2		];
	AX_UnitID		: ARRAY[1..3] OF BYTE := [1		, 1		, 	1		];	

	KK: INT;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
TRIG_CmdP_On			(CLK := IN_CmdP_On);						
TRIG_CmdP_Off			(CLK := IN_CmdP_Off);							
TRIG_CmdQ_On			(CLK := IN_CmdQ_On);                        
TRIG_CmdQ_Off			(CLK := IN_CmdQ_Off);                      
TRIG_CmdCosPhi_On		(CLK := IN_CmdCosPhi_On);              
TRIG_CmdCosPhi_Off		(CLK := IN_CmdCosPhi_Off);            
TRIG_CmdReset			(CLK := IN_CmdReset);
TRIG_FreqReg_On			(CLK := IN_CmdFreqregOn);
TRIG_FreqReg_Off		(CLK := IN_CmdFreqregOff);
TRIG_UReg_On			(CLK := IN_CmdUregOn);			
TRIG_UReg_Off			(CLK := IN_CmdUregOff);
TRIG_CmdGridFormer		(CLK := IN_CmdGridFormer);
TRIG_CmdGridFeeder		(CLK := IN_CmdGridFeeder);
TRIG_CmdMicroCyclingOn	(CLK := IN_CmdMicroCyclingOn AND MesMicroCyclingAllowed);
TRIG_CmdMicroCyclingOff	(CLK := IN_CmdMicroCyclingOff OR Trig_MicroCyclingNoLongerAllowed.Q);	
TRIG_CmdOpenAC			(CLK := IN_CmdOpenAC);
TRIG_CmdOpenDC			(CLk := IN_CmdOpenDC);
TRIG_CmdStop			(CLK := IN_CmdStop);
TRIG_CmdStandby			(CLK := IN_CmdStandby  AND NOT TP_CmdStop.Q );
TRIG_CmdStart			(CLK := IN_CmdStart AND NOT TP_CmdStop.Q AND NOT IN_CmdStopOperation AND NOT IN_CmdPreventStart);
TRIG_CmdBlackStart		(CLK := IN_CmdBlackStart);	
TRIG_CmdPcsLocal		(CLk := IN_CmdInvLocal);
TRIG_LowLowSoC			(clk := DataSystemBMS.MesSoCConnected <= A1_PP.ParamSocVeryVeryLow);
	
TP_CmdPreStop	(IN := TRIG_CmdStop.Q, 												PT := T#1S500MS);
TP_CmdPreStart	(IN := TRIG_CmdStart.Q, 											PT := ParamTimePulseTrig);
TP_CmdOpenAC	(IN := TRIG_CmdOpenAC.Q, 											PT := ParamTimePulseTrig);
TP_CmdOpenDC	(IN := TRIG_CmdOpenDC.Q, 											PT := ParamTimePulseTrig);
TP_CmdStop		(IN := F_TrigPreStop.Q, 											PT := ParamTimePulseTrig);
TP_CmdStart		(IN := F_TrigPreStart.Q, 											PT := ParamTimePulseTrig);
TP_CmdStandby	(IN := TRIG_CmdStop.Q OR TRIG_CmdStandby.Q OR TRIG_LowLowSoC.Q, 	PT := ParamTimePulseTrig);
TP_Reset		(IN := TRIG_CmdReset.Q, 											PT := ParamTimePulseTrig);


F_TrigPreStart	(CLK := TP_CmdPreStart.Q);
F_TrigPreStop	(CLK := TP_CmdPreStop.Q);


IF TRIG_CmdBlackStart.Q THEN
	IN_CmdBlackStart := FALSE;
END_IF
IF TRIG_CmdStop.Q THEN
	IN_CmdStop := FALSE;
END_IF
IF TRIG_CmdStart.Q THEN
	AX_ESS[ParamEssNum].AX_BAT[ParamPcsNum].IN_CmdCloseDC := TRUE;
	IN_CmdStart := FALSE;
END_IF
IF TRIG_CmdStandby.Q THEN
	IN_CmdStandby := FALSE;
END_IF

IF TRIG_CmdReset.Q THEN
	IN_CmdReset := FALSE;
END_IF

IF TRIG_CmdP_Off.Q THEN
MesDataExd.MesData.OUT_CmdP := FALSE;
	IN_CmdP_Off := FALSE;
END_IF
IF TRIG_CmdP_On.Q THEN
MesDataExd.MesData.OUT_CmdP := TRUE;
	IN_CmdP_On := FALSE;
END_IF
IF TRIG_CmdQ_Off.Q OR TRIG_CmdCosPhi_On.Q THEN
MesDataExd.MesData.OUT_CmdQ := FALSE;
	IN_CmdQ_Off := FALSE;
END_IF
IF TRIG_CmdQ_On.Q THEN
MesDataExd.MesData.OUT_CmdQ := TRUE;
	IN_CmdQ_On := FALSE;
END_IF
IF TRIG_CmdCosPhi_Off.Q OR TRIG_CmdQ_On.Q THEN
MesDataExd.MesData.OUT_CmdCosPhi := FALSE;
	IN_CmdCosPhi_Off := FALSE;
END_IF
IF TRIG_CmdCosPhi_On.Q THEN
MesDataExd.MesData.OUT_CmdCosPhi := TRUE;
MesDataExd.MesData.OUT_SetptCosPhi	:= IN_SetptCosPhi;
	IN_CmdCosPhi_On := FALSE;
END_IF

IF TRIG_FreqReg_On.Q THEN
MesDataExd.MesData.OUT_CmdFreqregMode := TRUE;
	IN_CmdFreqregOn := FALSE;
END_IF
IF TRIG_FreqReg_Off.Q THEN
MesDataExd.MesData.OUT_CmdFreqregMode := FALSE;
	IN_CmdFreqregOff := FALSE;
END_IF

IF TRIG_UReg_On.Q THEN
MesDataExd.MesData.OUT_CmdUregMode := TRUE;
	IN_CmdUregOn := FALSE;
END_IF
IF TRIG_UReg_Off.Q THEN
MesDataExd.MesData.OUT_CmdUregMode := FALSE;
	IN_CmdUregOff := FALSE;
END_IF
	
IF TRIG_CmdGridFormer.Q THEN
MesDataExd.MesData.OUT_CmdGridMode := TRUE;
	IN_CmdGridFormer := FALSE;
END_IF 
IF TRIG_CmdGridFeeder.Q OR TRIG_CmdStop.Q THEN //Si on fait une commande stop, on passe le mode en grid feeder
MesDataExd.MesData.OUT_CmdGridMode := FALSE;
	IN_CmdGridFeeder := FALSE;
END_IF

IF TRIG_CmdMicroCyclingOn.Q THEN
	IF DataSystemBMS.MesSoC > ParamMicroCyclingSoCMax *0.95 THEN
		MesMicroCyclingP := ABS(ParamMicroCyclingPower);
	ELSE
		MesMicroCyclingP := -ABS(ParamMicroCyclingPower);
	END_IF
	
	IN_CmdMicroCyclingOn := FALSE;
MesDataExd.MesData.OUT_CmdMicroCyclingMode := TRUE;
END_IF 
IF TRIG_CmdMicroCyclingOff.Q THEN
	IN_CmdMicroCyclingOff := FALSE;
MesDataExd.MesData.OUT_CmdMicroCyclingMode := FALSE;
END_IF 

IF TRIG_CmdPcsLocal.Q THEN
	IN_CmdInvLocal := FALSE;
MesDataExd.MesData.OUT_CmdInvLocal := NOT MesDataExd.MesData.OUT_CmdInvLocal;
END_IF

IN_CmdWatchdog := CalLocalTimeStruct.wSecond MOD 2 = 0;

MesData.OUT_CmdStop 		:= TP_CmdStop.Q;
MesData.OUT_CmdStart 		:= TP_CmdStart.Q;
MesData.OUT_CmdBlackStart 	:= TP_CmdBlackStart.Q;
MesData.OUT_CmdStandby 		:= TP_CmdStandby.Q;


Trig_Write[1](CLK := MEMCMP(pBuf1 :=ADR(AX_Cmd[1]), pBuf2 := ADR(AX_Cmd_Old[1]), n := SIZEOF(AX_CMD[1]))<>0);
Trig_Write[2](CLK := MEMCMP(pBuf1 :=ADR(AX_Cmd[2]), pBuf2 := ADR(AX_Cmd_Old[2]), n := SIZEOF(AX_CMD[2]))<>0);
Trig_Write[3](CLK := MEMCMP(pBuf1 :=ADR(AX_Cmd[3]), pBuf2 := ADR(AX_Cmd_Old[3]), n := SIZEOF(AX_CMD[3]))<>0);

IF MEMCMP(pBuf1 :=ADR(AX_Cmd[1]), pBuf2 := ADR(AX_Cmd_Old[1]), n := SIZEOF(AX_CMD[1]))<>0 THEN
	MEMCPY(destAddr := ADR(AX_Cmd_Old[1]), srcAddr := ADR(AX_Cmd[1]), n:= SIZEOF(AX_Cmd[1]));
END_IF
IF MEMCMP(pBuf1 :=ADR(AX_Cmd[2]), pBuf2 := ADR(AX_Cmd_Old[2]), n := SIZEOF(AX_CMD[2]))<>0 THEN
	MEMCPY(destAddr := ADR(AX_Cmd_Old[2]), srcAddr := ADR(AX_Cmd[2]), n:= SIZEOF(AX_Cmd[2]));
END_IF		
IF MEMCMP(pBuf1 :=ADR(AX_Cmd[3]), pBuf2 := ADR(AX_Cmd_Old[3]), n := SIZEOF(AX_CMD[3]))<>0 THEN
	MEMCPY(destAddr := ADR(AX_Cmd_Old[3]), srcAddr := ADR(AX_Cmd[3]), n:= SIZEOF(AX_Cmd[3]));
END_IF			

	// Manouvers (41708)
		AX_Cmd[1][1].1:= IN_CmdOpenAC;
		AX_Cmd[1][1].2:= IN_CmdOpenDC;
		
	// SoC	
		AX_Cmd[1][2]  := REAL_TO_WORD(ParamFreqRegSoCmax); 
		AX_Cmd[1][3]  := REAL_TO_WORD(ParamFreqRegSoCmin); 
		AX_Cmd[1][4]  := REAL_TO_WORD(TRUNC(DataSystemBMS.MesSoCConnected));		// SoC connected 
		
		
	// Param voltage regulation (activate in Function Mode)
		// Regulation from voltage
		AX_Cmd[1][7]  := REAL_TO_WORD(ParamQfU_UDbHigh)		; 
		AX_Cmd[1][8]  := REAL_TO_WORD(ParamQfU_Umax)		  	; 
		AX_Cmd[1][9]  := REAL_TO_WORD(ParamQfU_UDbLow)	 	; 
		AX_Cmd[1][10] := REAL_TO_WORD( ParamQfU_Umin	)  		; 
		
		IF ParamNbPcs > 0 THEN 
			AX_Cmd[1][11]  := REAL_TO_WORD(MIN(MAX(-ParamQfU_QDbHigh*ParamNbPcs/ParamPnom*1000.0, -1000 ), 1000))			; 
			AX_Cmd[1][12]  := REAL_TO_WORD(MIN(MAX(-ParamQfU_Qmax*ParamNbPcs/ParamPnom*1000.0, -1000 ), 1000))			  	; 
			AX_Cmd[1][13]  := REAL_TO_WORD(MIN(MAX(-ParamQfU_QDbLow*ParamNbPcs/ParamPnom*1000.0, -1000 ), 1000))		 	; 
			AX_Cmd[1][14]  := REAL_TO_WORD(MIN(MAX(-ParamQfU_Qmin*ParamNbPcs/ParamPnom*1000.0, -1000 ), 1000))		  		; 
		ELSE
			AX_Cmd[1][11]  := 0 ; 
			AX_Cmd[1][12]  := 0 ; 
			AX_Cmd[1][13]  := 0 ; 
			AX_Cmd[1][14]  := 0 ; 
		END_IF

		
		AX_Cmd[1][15] := REAL_TO_WORD(A1_PP.ParamNominalVoltage)	; 
		AX_Cmd[1][16] := REAL_TO_WORD(DataPDL.MesDataExd.MesData.MesU)	;	
		
	// Param frequency regulation 
		AX_Cmd[1][21] := REAL_TO_WORD(ParampfF_fDbHigh*100.0)		;
		AX_Cmd[1][22] := REAL_TO_WORD(ParamPfF_Fmax*100.0)		;
		AX_Cmd[1][23] := REAL_TO_WORD(ParamPfF_FDbLow*100.0)		;
		AX_Cmd[1][24] := REAL_TO_WORD(ParamPfF_Fmin*100.0)		;
		AX_Cmd[1][25] := REAL_TO_WORD(ParampfF_fDbHigh*100.0)		;
		AX_Cmd[1][26] := REAL_TO_WORD(ParamPfF_FDbLow*100.0)		;
		
		AX_Cmd[1][27] := REAL_TO_WORD(ParamPfF_FhystLow*100.0)	;
		AX_Cmd[1][28] := REAL_TO_WORD(ParamPfF_FhystHigh*100.0)	;		
		
		AX_Cmd[1][29] := REAL_TO_WORD(MIN(MAX(ParamPfF_PDbHigh/ParamPnom*1000.0 , -1000 ), 1000)	)	;
		AX_Cmd[1][30] := REAL_TO_WORD(MIN(MAX(ParamPfF_Pmin/ParamPnom	*1000.0, -1000 ), 1000)	)		;  
		AX_Cmd[1][31] := REAL_TO_WORD(MIN(MAX(ParamPfF_PDbLow/ParamPnom*1000.0, -1000 ), 1000)	)		; 
		AX_Cmd[1][32] := REAL_TO_WORD(MIN(MAX(ParamPfF_Pmax/ParamPnom*1000.0, -1000 ), 1000)		)	;  
		AX_Cmd[1][33] := REAL_TO_WORD(MIN(MAX(ParamPfF_PDbHigh/ParamPnom*1000.0, -1000 ), 1000)	)		;		// P5 . 
		AX_Cmd[1][34] := REAL_TO_WORD(MIN(MAX(ParamPfF_PDbLow/ParamPnom*1000.0, -1000 ), 1000)	)		; 


		AX_Cmd[1][35] := TIME_TO_WORD(ParamTimeSoCRangeReachedRmp/1000*10);				// (s) Time to go to 0 power (if SoC issue or if end of stable)
		AX_Cmd[1][37] := TIME_TO_WORD(ParamTimeEnterStblPriorRmp/1000*10);					// (s) Time to wait after entering the stable before ramping the P back to the setpoint
		AX_Cmd[1][36] := TIME_TO_WORD(ParamTimeFreqRegStbDuration/1000*10);				// (s) Time to stay in the stable area before it goes to 0
		
	// Function Mode
		AX_Cmd[1][38].0:= IN_CmdWatchdog; 							// PCS stops (hard stop) if watchdog does not change during more than 10sec
		AX_Cmd[1][38].1:= TP_Reset.Q;							// Reset
		AX_Cmd[1][38].2:= MesDataExd.MesData.OUT_CmdGridMode;	 				// To be tested
		AX_Cmd[1][38].3:= ParamSetPtModbusMode;					// Write 1 to send Setpoint via Modbus 
		AX_Cmd[1][38].4:= MesDataExd.MesData.OUT_CmdGridMode;				// Write 1 to switch to Master (to be tested)
		AX_Cmd[1][38].5:= MesDataExd.MesData.OUT_CmdStart; 				// Start: pas besoin de maintenir
		AX_Cmd[1][38].6:= MesDataExd.MesData.OUT_CmdStop; 					// Hard Stop : Open everything and stop charger .
		AX_Cmd[1][38].7:= MesDataExd.MesData.OUT_CmdP;						// P regulation enabled 
		AX_Cmd[1][38].8:= MesDataExd.MesData.OUT_CmdFreqregMode; 			// Send one to activate the Frequency regulation, to be tested
		AX_Cmd[1][38].9:= MesDataExd.MesData.OUT_CmdUregMode; 				// Send one to activate the voltage regulation, to be tested
		AX_Cmd[1][38].10:= MesDataExd.MesData.OUT_CmdQ;	 				// Q regulation enabled 
		AX_Cmd[1][38].11:= MesDataExd.MesData.OUT_CmdCosPhi;				// Cmd CosPhi ack
		AX_Cmd[1][38].12:= NOT ParamPoverQ;						// Param Q over P for Jema
		AX_Cmd[1][38].13:= ParamLVRT_Enabled;					// Param LVRT enable
		AX_Cmd[1][38].14:= ParamAntiIslanding_Enabled;			// Param Anti Islanding enable
		AX_Cmd[1][38].15:= MesDataExd.MesData.OUT_CmdStandby;				// Cmd Standby
		
		
	// Param Frequency regulation (2)
		AX_Cmd[1][39] := REAL_TO_WORD(DataSystemBMS.MesUdc);
	 
		AX_Cmd[1][40] := BOOL_TO_WORD(ParamDeactivateWatchdog);
	
	
		
	// Setpoints
		AX_Cmd[2][1] := REAL_TO_WORD.MesDataExd.MesData.OUT_SetptP);					// Setpoint active power in kW
		AX_Cmd[2][2] := REAL_TO_WORD.MesDataExd.MesData.OUT_SetptQ);					// Setpoint reactive power in kVar
		AX_Cmd[2][4] := REAL_TO_WORD.MesDataExd.MesData.OUT_SetptCosPhi*1000);		// Setpoint CosPhi
		
	
//MesBatInit := DataSystemBMS.		

		AX_Cmd[2][18] := REAL_TO_WORD(DataSystemBMS.MesSoH);
		AX_Cmd[2][19] := REAL_TO_WORD(DataSystemBMS.MesUdcMin*1000);
		AX_Cmd[2][22] := REAL_TO_WORD(DataSystemBMS.MesUdcMax*1000);
		AX_Cmd[2][25] := UINT_TO_WORD(DataSystemBMS.MesNbRackConnected);
		AX_Cmd[2][26] := UINT_TO_WORD(DataSystemBMS.MesNbRackTot);
		AX_Cmd[2][28] := REAL_TO_WORD(DataSystemBMS.MesIdc*10);

		
		AX_Cmd[3][1] := REAL_TO_WORD.MesDataExd.MesData.OUT_SetptV);
		AX_Cmd[3][2] := REAL_TO_WORD.MesDataExd.MesData.OUT_SetptF*100);
		AX_Cmd[3][3] := REAL_TO_WORD(ParamFLow_droop*100);
		AX_Cmd[3][4] := REAL_TO_WORD(ParamFHigh_droop*100);
		AX_Cmd[3][5] := REAL_TO_WORD(ParamULow_droop); 
		AX_Cmd[3][6] := REAL_TO_WORD(ParamUHigh_droop);
		
		
// WRITE COMMAND //
	FOR KK := 1 TO 3 DO
		CmdWrite[KK] := ClockWrite OR Trig_Write[KK].Q;
	END_FOR
	
	// MODBUS REQUEST //	
		// Modbus Blocks write			
		ModbusWrite[1]
		(
			nTCPport			:= ParamTcpPort,
			pSrcAddr 			:= ADR(AX_Cmd[1]) ,
			cbLength			:= SIZEOF(AX_Cmd[1]) , 
			nQuantity 			:= AX_QTY[1],			
			Reset				:= CmdClearFault_G, 
			sIPAddr				:= ParamIPAddress , 
			nUnitID				:= ParamUnitID , 
			nMBAddr				:= AX_Adr[1] , 
			tTimeout			:= ParamTimeout ,
			WriteCmd			:= (ClockWrite OR Trig_Write[2].Q) AND MesCP_Write , 
			ModbusWriteAlarm	=> MesModbusWriteCmdAlarm[1] , 
			ErrorId				=> MesModbusWriteCode[1]
		);   
			
		// Modbus Blocks write			
		ModbusWrite[2]
		(
			nTCPport			:= ParamTcpPort,
			pSrcAddr 			:= ADR(AX_Cmd[2]) ,
			cbLength			:= SIZEOF(AX_Cmd[2]) , 
			nQuantity 			:= AX_QTY[2],			
			Reset				:= CmdClearFault_G, 
			sIPAddr				:= ParamIPAddress , 
			nUnitID				:= ParamUnitID , 
			nMBAddr				:= AX_Adr[2] , 
			tTimeout			:= ParamTimeout ,
			WriteCmd			:= (ClockWrite OR Trig_Write[2].Q)  AND MesCP_Write , 
			ModbusWriteAlarm	=> MesModbusWriteCmdAlarm[2] , 
			ErrorId				=> MesModbusWriteCode[2]
		);   				
		
		ModbusWrite[3]
		(
			nTCPport			:= ParamTcpPort,
			pSrcAddr 			:= ADR(AX_Cmd[3]) ,
			cbLength			:= SIZEOF(AX_Cmd[3]) , 
			nQuantity 			:= AX_QTY[3],			
			Reset				:= CmdClearFault_G, 
			sIPAddr				:= ParamIPAddress , 
			nUnitID				:= ParamUnitID, 
			nMBAddr				:= AX_Adr[3] , 
			tTimeout			:= ParamTimeout ,
			WriteCmd			:= (ClockWrite OR Trig_Write[3].Q)  AND MesCP_Write , 
			ModbusWriteAlarm	=> MesModbusWriteCmdAlarm[3] , 
			ErrorId				=> MesModbusWriteCode[3]
		); 		
		
		
// ANALOG CMD 
OUT_SetptP_IO		:= REAL_TO_INT((32767-0)/(2*ParamPnom)* MesDataExd.MesData.OUT_SetptP)+32767/2) ;
OUT_SetptQ_IO		:= REAL_TO_INT((32767-0)/(2*ParamPnom)* MesDataExd.MesData.OUT_SetptQ)+32767/2) ;	
		]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_PCS">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_AlarmManagement">
      <LineId Id="1432" Count="135" />
      <LineId Id="449" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_CP">
      <LineId Id="26" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_Evaluate">
      <LineId Id="1727" Count="0" />
      <LineId Id="1508" Count="218" />
      <LineId Id="101" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_Init">
      <LineId Id="58" Count="5" />
      <LineId Id="47" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_Read">
      <LineId Id="5929" Count="4" />
      <LineId Id="5879" Count="16" />
      <LineId Id="5411" Count="0" />
      <LineId Id="5896" Count="2" />
      <LineId Id="5412" Count="9" />
      <LineId Id="5707" Count="0" />
      <LineId Id="5422" Count="2" />
      <LineId Id="5426" Count="3" />
      <LineId Id="5899" Count="0" />
      <LineId Id="5430" Count="0" />
      <LineId Id="5900" Count="1" />
      <LineId Id="5431" Count="12" />
      <LineId Id="5445" Count="1" />
      <LineId Id="5457" Count="2" />
      <LineId Id="5462" Count="6" />
      <LineId Id="5737" Count="0" />
      <LineId Id="5483" Count="1" />
      <LineId Id="5486" Count="0" />
      <LineId Id="5489" Count="1" />
      <LineId Id="5734" Count="0" />
      <LineId Id="5732" Count="0" />
      <LineId Id="5735" Count="0" />
      <LineId Id="5733" Count="0" />
      <LineId Id="5657" Count="0" />
      <LineId Id="5505" Count="3" />
      <LineId Id="5740" Count="0" />
      <LineId Id="5514" Count="0" />
      <LineId Id="5516" Count="1" />
      <LineId Id="5746" Count="0" />
      <LineId Id="5741" Count="2" />
      <LineId Id="5518" Count="0" />
      <LineId Id="5745" Count="0" />
      <LineId Id="5800" Count="0" />
      <LineId Id="5826" Count="0" />
      <LineId Id="5747" Count="1" />
      <LineId Id="5179" Count="0" />
      <LineId Id="5853" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_StateManager">
      <LineId Id="58" Count="0" />
      <LineId Id="85" Count="1" />
      <LineId Id="3" Count="2" />
      <LineId Id="59" Count="0" />
      <LineId Id="6" Count="2" />
      <LineId Id="60" Count="0" />
      <LineId Id="9" Count="2" />
      <LineId Id="61" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_PCS.M_WriteCommand">
      <LineId Id="2994" Count="22" />
      <LineId Id="3343" Count="0" />
      <LineId Id="3017" Count="219" />
      <LineId Id="3239" Count="0" />
      <LineId Id="3242" Count="6" />
      <LineId Id="3325" Count="3" />
      <LineId Id="3324" Count="0" />
      <LineId Id="3249" Count="60" />
      <LineId Id="881" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>